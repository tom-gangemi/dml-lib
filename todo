- [ ] Database.DmlOptions options to pass 
    — [x] support a global default (uow.options(opts)) 
    - [ ] support per-operation override (.withOptions(perOpOpts))
- [ ] Fluent Bulk records update without the loop e.g.
    - [x] DML.Records(opportunities).with(Opportunity.Status, 'Closed Won') — loop-free builder that batches field patches, applies FLS (per mode), then registers the op.
- [ ] Bulk DMLs — group by SObjectType and operation; execute in chunked batches (default 200) to minimize statements and respect limits.
- [ ] Savepoint + rollback — wrap commitWork() in a savepoint; 
    - [x] on error rollback everything;
    - [ ] clear internal state afterward.
- [ ] General and per-operation overrides e.g. new DML(options), registerInsert(..., options) 
- [ ] allow allOrNone, DMLOptions, and SecurityMode per op; merge overrides over UoW defaults.
- [x] Update list of records at once e.g accounts.with(Account.Unit, 'test') - DML.Records(records).with(field, value)
- [ ] Static DML eg. DML.Global.toInsert(); DML.Global.commitWork(); DML.Shared.toInsert();
- [x] Field-Level Security
    - [x] USER_MODE — enforce CRUD/FLS strictly; fail on violations with clear errors.
    - [x] SYSTEM_MODE — skip CRUD/FLS checks (still subject to validation rules)
    - [ ] stripInaccessible (?) — SANITIZE mode: apply Security.stripInaccessible(CREATABLE/UPDATABLE, records); record stripped fields in results.
    - [ ] Unit Tests
- [ ] Configurable Sharing Mode
    - [x] Inherited sharing by default — keep DML.cls as inherited sharing
    - [x] with sharing
    - [x] without sharing
    - [ ] Sharing mode configurable per operation (?)
- [ ] Relatonships
    - [ ] Explicit dependency ordering — guarantee parents insert before children; deletes run child-first. Accept/derive a type order graph (parents → children) so inserts/upserts happen in safe sequence even if registered out of order; apply lookup values just-in-time before child insert/upsert.
- [ ] Preview mode or debug mode (?) - dry-run uow.preview() shows per-type op counts, fields to mutate, effective chunk size/allOrNone/security mode, and pending relationships; no DML.
- [ ] Retry strategy — optional, 
    - [ ] bounded retry on UNABLE_TO_LOCK_ROW, 
    - [ ] splitting chunks when retried; record retry trace in results.
    - [ ] Chunk size
```java
dml.withRetryPolicy(new RetryPolicy()
  .maxAttempts(3)
  .initialDelayMs(25)  
  .splitOnRetry(true)); // split chunk into smaller pieces when retrying
```
- [ ] Mocking
    - [ ] Mock Ids — generator produces valid 18-char Ids with correct key prefix; assign only in fake provider.
    - [ ] Registry of number of inserted records — per type & per batch counters.
    - [ ] Registry of issued DML for each operation — capture exact batches for insert/update/upsert/delete/etc.
    - [ ] DML Counter — total DML statements and rows processed; expose via results.
    - [ ] Mock Errors - mock different DML errors.
    - [ ] Update/Upsert should update record reference
```java
    DML.mock('mockId').mockAll();
    DML.mock('mockId').mockInsert();
    DML.mock('mockId').mockUpdate();

    DML.get('mockId').getInserted(Account.SObjectType);
    DML.get('mockId').getUpdated(Account.SObjectType);
```
- [ ] Supported Operations:
    - [ ] insert
    - [ ] update
    - [ ] upsert
    - [ ] delete
    - [ ] undelete
    - [ ] harddelete (soft delete + emptyRecycleBin)
    - [ ] merge (surface MergeResult[])
    - [ ] publish event (__e queued and published during commit; include outcomes)
- [ ] Return Database.Result or some other wrapper — return UowResult with per-op DmlOutcome, raw SaveResult[]/DeleteResult[]/MergeResult[], limits snapshot, events, retries.
- [] Commit hooks - `DML.Hook`
    - [x] Before commit hook — pure in-memory prep (e.g., finalize patches) before any DML.
    - [x] After commit hook — enqueue async work / notifications; fires only if commit succeeds.
    - [ ] before hook should got the list of records to be inserted
    - [ ] after hook should get the results
- [ ] 100% code coverage — tests for happy/error paths, CRUD/FLS modes, DmlOptions, chunking, lock-retry, preview, hooks, mocking registries, and relationship ordering.
- [ ] Trigger bypass adapter(optional) — new apex class DML.Bypass interface that will get sobjectType and based on it can have logic to bypass different triggers
- [ ] Chunk Size — protect against DML row/CPU limits. uow.withChunkSize(200) (default 200) to mimic trigger batch sizes and reduce recursion; auto-downshift on retries if enabled.
- [ ] Rich result model (optional) — include outcomes, limits, stripped fields, warnings, event results, and retry trace; provide toJson() for logging.
```java
DML.SaveResult {
    // copy Database.SaveResult
}

class DmlOutcome {
  public SObjectType type;
  public Operation op;                 // INSERT/UPDATE/UPSERT/DELETE/UNDELETE/HARDDELETE/MERGE/EVENT
  public Integer requested;
  public Integer succeeded;
  public Database.SaveResult[] saveResults; // or DeleteResult/MergeResult
  public Database.Error[] errors;           // flattened
  public Long durationMs;
  public Boolean partial;                   // allOrNone=false and some failed
}

class UowResult {
  public Boolean success;
  public Map<SObjectType, Map<Operation, DmlOutcome>> byTypeOp;
  public Map<Id, Id> idMap;                 // temp→real (if you generate mock Ids)
  public LimitsSnapshot limits;             // statements, rows, CPU
  public List<EventOutcome> events;         // publish results
  public List<RetryEvent> retries;          // lock retry trace
}
```
- [ ] Discard changes after commitWork()
- [ ] Connector to SOQL Lib — inject selectors/repositories for any reads inside commit (dedupe, external-id resolution); selectors honor chosen sharing mode.
- [ ] Dedupling registration — when records with the same Id are registered and modify the same field: policy LAST_WINS | THROW; track warnings when deduping occurs.
- [ ] Observability hooks — uow.withLogger(ILogger) to emit timings, limits, retries, per-op summaries; keep lightweight to avoid CPU spikes.
- [ ] Dependency graph
    - [ ] Try to do as less DMLs as possible
    - [ ] Try to build dependency graph between objects (tree?)
- [ ] insertImmediately, updateImmediately, etc.
---

```java
DML.systemMode();

DML.Insert.add();

DML.Update.userMode().add();

DML.Delete.userMode().add();

DML.commitWork();

DML dml = new DML();

dml.toInsert(record);

DML.Commitable db = new DML();

```