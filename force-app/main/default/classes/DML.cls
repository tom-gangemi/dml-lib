/**
 * Copyright (c) 2025 Beyond The Cloud Sp. z o.o. (BeyondTheCloud.Dev)
 * Licensed under the MIT License (https://github.com/beyond-the-cloud-dev/dml-lib/blob/main/LICENSE)
 *
 * v1.6.0
 *
 * PMD False Positives:
 * - MethodNamingConventions - Some methods are uppercase to indicate that they are "constructors" of othere internal classes
 * - CyclomaticComplexity: It is a library and we tried to put everything into ONE class
 * - CognitiveComplexity: It is a library and we tried to put everything into ONE class
 * - ExcessivePublicCount: It is a library and we tried to put everything into ONE class
 * - FieldDeclarationsShouldBeAtStart: The most important methods and interfaces are at the top of the class
 * - AvoidDebugStatements: Debug statements are used for debugging purposes
 * - OperationWithLimitsInLoop: DMLs are executed by SObject Type and the loop is through different types
 * - ApexCRUDViolation: DMLs are executed by User Mode or System Mode
**/
@SuppressWarnings('PMD.MethodNamingConventions,PMD.CyclomaticComplexity,PMD.CognitiveComplexity,PMD.ExcessivePublicCount,PMD.FieldDeclarationsShouldBeAtStart,PMD.AvoidDebugStatements,PMD.OperationWithLimitsInLoop,PMD.ApexCRUDViolation')
public inherited sharing class DML implements Commitable {
	public static Commitable Shared {
		get {
			if (DML.Shared == null) {
				DML.Shared = new DML();
			}
			return DML.Shared;
		}
		private set;
	}

	public static Record Record(SObject record) {
		return new DmlRecord(record);
	}

	public static Record Record(Id recordId) {
		return new DmlRecord(recordId);
	}

	public static Records Records(List<SObject> records) {
		return new DmlRecords(records);
	}

	public static Records Records(Iterable<Id> recordIds) {
		return new DmlRecords(recordIds);
	}

	public interface Commitable {
		// Insert
		Commitable toInsert(SObject record);
		Commitable toInsert(DML.Record record);
		Commitable toInsert(List<SObject> records);
		Commitable toInsert(DML.Records records);
		// Update
		Commitable toUpdate(SObject record);
		Commitable toUpdate(DML.Record record);
		Commitable toUpdate(List<SObject> records);
		Commitable toUpdate(DML.Records records);
		// Upsert
		Commitable toUpsert(SObject record);
		Commitable toUpsert(DML.Record record);
		Commitable toUpsert(List<SObject> records);
		Commitable toUpsert(DML.Records records);
		// Delete
		Commitable toDelete(Id recordId);
		Commitable toDelete(SObject record);
		Commitable toDelete(Iterable<Id> recordIds);
		Commitable toDelete(List<SObject> records);
		// Undelete
		Commitable toUndelete(Id recordId);
		Commitable toUndelete(SObject record);
		Commitable toUndelete(Iterable<Id> recordIds);
		Commitable toUndelete(List<SObject> records);
		// Platform Event
		Commitable toPublish(SObject record);
		Commitable toPublish(List<SObject> records);
		// Mocking
		Commitable identifier(String dmlIdentifier); // used for mocking and tracking results
		// Debug
		void preview();
		// Field Level Security
		Commitable userMode();
		Commitable systemMode();
		// Sharing Mode
		Commitable withSharing();
		Commitable withoutSharing();
		// Other configs
		Commitable allowPartialSuccess();
		Commitable options(Database.DmlOptions options);
		Commitable commitHook(DML.Hook callback);
		// Save
		Result dryRun();
		Result commitWork();
		Result hardCommitWork();
	}

	public interface Record {
		Record with(SObjectField field, Object value); 
		Record withRelationship(SObjectField targetField, SObject relatedRecord);
		Record withRelationship(SObjectField targetField, SObjectField relatedObjectExternalIdField, Object relatedRecordExternalId);
		
		// for internal use only
		EnhancedRecord get();
	}

	public interface Records {
		Records with(SObjectField field, Object value); 
		Records withRelationship(SObjectField targetField, SObject relatedRecord);
		Records withRelationship(SObjectField targetField, SObjectField relatedObjectExternalIdField, Object relatedRecordExternalId);
		
		// for internal use only
		List<Record> get();
	}

	public interface Result {
		List<OperationResult> all();
		// Per Operation
		List<OperationResult> inserted();
		List<OperationResult> updated();
		List<OperationResult> upserted();
		List<OperationResult> deleted();
		List<OperationResult> undeleted();
		List<OperationResult> published();
		// Per Object Type
		OperationResult inserted(Schema.SObjectType objectType);
		OperationResult updated(Schema.SObjectType objectType);
		OperationResult upserted(Schema.SObjectType objectType);
		OperationResult deleted(Schema.SObjectType objectType);
		OperationResult undeleted(Schema.SObjectType objectType);
		OperationResult published(Schema.SObjectType objectType);
	}

	public interface OperationResult {
		Type getType();
		Schema.SObjectType getObjectType();
		Boolean hasFailures();
		Integer requestedCount();
		Integer succeededCount();
		Integer failedCount();
		List<SObject> records();
		List<RecordResult> getRecordResults();
	}

	public interface RecordResult {
		Id getId();
		Boolean isSuccess();
		List<Error> getErrors();
	}

	public interface Error {
		String getMessage();
		System.StatusCode getStatusCode();
		List<String> getFields();
	}

	// Mockking

	public static Mockable whenDmlIdentifier(String dmlIdentifier) {
		if (!DML.dmlIdentifierToMock.containsKey(dmlIdentifier)) {
			DML.dmlIdentifierToMock.put(dmlIdentifier, new DmlMock());
		}
		return DML.dmlIdentifierToMock.get(dmlIdentifier);
	}

	public interface Mockable {
		Mockable thenMockAllDmls();
		// Per Operation
		Mockable thenMockAllInserts();
		Mockable thenMockAllUpdates();
		Mockable thenMockAllUpserts();
		Mockable thenMockAllDeletes();
		Mockable thenMockAllUndelete();
		Mockable thenMockAllPublishes();
		// Per Object Type
		Mockable thenMockInsertFor(SObjectType objectType);
		Mockable thenMockUpdateFor(SObjectType objectType);
		Mockable thenMockUpsertFor(SObjectType objectType);
		Mockable thenMockDeleteFor(SObjectType objectType);
		Mockable thenMockUndeletFor(SObjectType objectType);
		Mockable thenMockPublishFor(SObjectType objectType);
	}

	public static Result getMockResulfForDml(String dmlIdentifier) {
		if (!DML.dmlIdentifierToResult.containsKey(dmlIdentifier)) {
			throw new DmlException('No result found for dml identifier: ' + dmlIdentifier);
		}
		return DML.dmlIdentifierToResult.get(dmlIdentifier);
	}

	// Hooks

	public interface Hook {
		void before();
		void after();
	}

	// Implementation

	private DmlOperation insertCommand = new InsertOperation();
	private DmlOperation updateCommand = new UpdateOperation();
	private DmlOperation upsertCommand = new UpsertOperation();
	private DmlOperation deleteCommand = new DeleteOperation();
	private DmlOperation undeleteCommand = new UndeleteOperation();
	private DmlOperation publishCommand = new PlatformEventOperation();

	public enum Type { INSERT_DML, UPDATE_DML, UPSERT_DML, DELETE_DML, UNDELETE_DML, HARD_DELETE_DML, MERGE_DML, PUBLISH_DML }

	private DML.Hook hook = null;

	private String dmlIdentifier = null;

	private static Map<String, Result> dmlIdentifierToResult = new Map<String, Result>();
	private static Map<String, DmlMock> dmlIdentifierToMock = new Map<String, DmlMock>();
	public static RandomIdGenerator randomIdGenerator = new RandomIdGenerator();

	public DML() {} // default constructor

	public DML(List<SObjectType> customExecutionOrder) {
		this.insertCommand.executionOrder(customExecutionOrder);
		this.updateCommand.executionOrder(customExecutionOrder);
		this.upsertCommand.executionOrder(customExecutionOrder);
		this.deleteCommand.executionOrder(customExecutionOrder);
		this.undeleteCommand.executionOrder(customExecutionOrder);
	}

	// Insert

	public Commitable toInsert(SObject record) {
		return this.toInsert(DML.Record(record));
	}

	public Commitable toInsert(DML.Record record) {
		this.insertCommand.register(record);
		return this;
	}

	public Commitable toInsert(List<SObject> records) {
		return this.toInsert(DML.Records(records));
	}
	
	public Commitable toInsert(DML.Records records) {
		this.insertCommand.register(records);
		return this;
	}

	// Update
	
	public Commitable toUpdate(SObject record) {
		return this.toUpdate(DML.Record(record));
	}

	public Commitable toUpdate(DML.Record record) {
		this.updateCommand.register(record);
		return this;
	}

	public Commitable toUpdate(List<SObject> records) {
		return this.toUpdate(DML.Records(records));
	}

	public Commitable toUpdate(DML.Records records) {
		this.updateCommand.register(records);
		return this;
	}

	// Upsert

	public Commitable toUpsert(SObject record) {
		return this.toUpsert(DML.Record(record));
	}

	public Commitable toUpsert(DML.Record record) {
		this.upsertCommand.register(record);
		return this;
	}

	public Commitable toUpsert(List<SObject> records) {
		return this.toUpsert(DML.Records(records));
	}

	public Commitable toUpsert(DML.Records records) {
		this.upsertCommand.register(records);
		return this;
	}

	// Delete

	public Commitable toDelete(Id recordId) {
		this.deleteCommand.register(DML.Record(recordId));
		return this;
	}

	public Commitable toDelete(SObject record) {
		return this.toDelete(record.Id);
	}

	public Commitable toDelete(Iterable<Id> recordIds) {
		this.deleteCommand.register(DML.Records(recordIds));
		return this;
	}

	public Commitable toDelete(List<SObject> records) {
		this.deleteCommand.register(DML.Records(records));
		return this;
	}

	// Undelete

	public Commitable toUndelete(Id recordId) {
		this.undeleteCommand.register(DML.Record(recordId));
		return this;
	}

	public Commitable toUndelete(SObject record) {
		return this.toUndelete(record.Id);
	}

	public Commitable toUndelete(Iterable<Id> recordIds) {
		this.undeleteCommand.register(DML.Records(recordIds));
		return this;
	}

	public Commitable toUndelete(List<SObject> records) {
		this.undeleteCommand.register(DML.Records(records));
		return this;
	}

	// Platform Event

	public Commitable toPublish(SObject record) {
		this.publishCommand.register(DML.Record(record));
		return this;
	}

	public Commitable toPublish(List<SObject> records) {
		this.publishCommand.register(DML.Records(records));
		return this;
	}

	// Identifier

	public Commitable identifier(String dmlIdentifier) {
		this.dmlIdentifier = dmlIdentifier;
		this.insertCommand.identifier(dmlIdentifier);
		this.updateCommand.identifier(dmlIdentifier);
		this.upsertCommand.identifier(dmlIdentifier);
		this.deleteCommand.identifier(dmlIdentifier);
		this.undeleteCommand.identifier(dmlIdentifier);
		this.publishCommand.identifier(dmlIdentifier);
		return this;
	}

	// Debug

	public void preview() {
		this.insertCommand.preview();
		this.updateCommand.preview();
		this.upsertCommand.preview();
		this.deleteCommand.preview();
		this.undeleteCommand.preview(); 
		this.publishCommand.preview();
	}

	// Field Level Security

	public Commitable userMode() {
		this.insertCommand.userMode();
		this.updateCommand.userMode();
		this.upsertCommand.userMode();
		this.deleteCommand.userMode();
		this.undeleteCommand.userMode();
		this.publishCommand.userMode();
		return this;
	}

	public Commitable systemMode() {
		this.insertCommand.systemMode();
		this.updateCommand.systemMode();
		this.upsertCommand.systemMode();
		this.deleteCommand.systemMode();
		this.undeleteCommand.systemMode();
		this.publishCommand.systemMode();
		return this;
	}

	// Sharing Mode

	public Commitable withSharing() {
		this.updateCommand.withSharing();
		this.upsertCommand.withSharing();
		this.deleteCommand.withSharing();
		this.undeleteCommand.withSharing();
		this.publishCommand.withSharing();
		return this;
	}

	public Commitable withoutSharing() {
		this.insertCommand.withoutSharing();
		this.updateCommand.withoutSharing();
		this.upsertCommand.withoutSharing();
		this.deleteCommand.withoutSharing();
		this.undeleteCommand.withoutSharing();
		this.publishCommand.withoutSharing();
		return this;
	}

	// Other configs

	public Commitable allowPartialSuccess() {
		this.insertCommand.allowPartialSuccess();
		this.updateCommand.allowPartialSuccess();
		this.upsertCommand.allowPartialSuccess();
		this.deleteCommand.allowPartialSuccess();
		this.undeleteCommand.allowPartialSuccess();
		return this;
	}

	public Commitable options(Database.DmlOptions options) {
		this.insertCommand.options(options);
		this.updateCommand.options(options);
		return this;
	}

	// Hooks

	public Commitable commitHook(DML.Hook callback) {
		this.hook = callback;
		return this;
	}

	public Result dryRun() {
		Savepoint savePoint = Database.setSavepoint();

		this.hook?.before();

		DMLResult result = new DmlResult();

		result.add(Type.INSERT_DML, this.insertCommand.commitWork());
		result.add(Type.UPSERT_DML, this.upsertCommand.commitWork());
		result.add(Type.UPDATE_DML, this.updateCommand.commitWork());
		result.add(Type.DELETE_DML, this.deleteCommand.commitWork());
		result.add(Type.UNDELETE_DML, this.undeleteCommand.commitWork());
		result.add(Type.PUBLISH_DML, this.publishCommand.commitWork());

		this.hook?.after();

		Database.rollback(savePoint);

		return result;
	}

	public Result commitWork() {
		DMLResult result = new DmlResult();

		try {
			this.hook?.before();

			result.add(Type.INSERT_DML, this.insertCommand.commitWork());
			result.add(Type.UPSERT_DML, this.upsertCommand.commitWork());
			result.add(Type.UPDATE_DML, this.updateCommand.commitWork());
			result.add(Type.DELETE_DML, this.deleteCommand.commitWork());
			result.add(Type.UNDELETE_DML, this.undeleteCommand.commitWork());
			result.add(Type.PUBLISH_DML, this.publishCommand.commitWork());

			DML.dmlIdentifierToResult.put(this.dmlIdentifier, result);

			this.hook?.after();
		} catch (Exception e) {
			throw e;
		} finally {
			this.reset();
		}

		return result;
	}

	public Result hardCommitWork() {
		Savepoint savePoint = Database.setSavepoint();

		try {
			return this.commitWork();
		} catch (Exception e) {
			Database.rollback(savePoint);
			throw e;
		} finally {
			Database.releaseSavepoint(savePoint);
		}
	}

	private void reset() {
		this.insertCommand = new InsertOperation();
		this.updateCommand = new UpdateOperation();
		this.upsertCommand = new UpsertOperation();
		this.deleteCommand = new DeleteOperation();
		this.undeleteCommand = new UndeleteOperation();
		this.publishCommand = new PlatformEventOperation();
	}

	public class DmlResult implements DML.Result {
		private Map<Type, Map<SObjectType, OperationResult>> operationResultsByObjectType = new Map<Type, Map<SObjectType, OperationResult>>{
			Type.INSERT_DML => new Map<SObjectType, OperationResult>(),
			Type.UPDATE_DML => new Map<SObjectType, OperationResult>(),
			Type.UPSERT_DML => new Map<SObjectType, OperationResult>(),
			Type.DELETE_DML => new Map<SObjectType, OperationResult>(),
			Type.UNDELETE_DML => new Map<SObjectType, OperationResult>(),
			Type.PUBLISH_DML => new Map<SObjectType, OperationResult>()
		};

		public DmlResult add(Type operationType, List<OperationResult> results) {
			for (OperationResult result : results) {
				this.operationResultsByObjectType.get(operationType).put(result.getObjectType(), result);
			}

			return this;
		}

		public List<OperationResult> inserted() {
			return this.getOperationResults(Type.INSERT_DML);
		}

		public List<OperationResult> updated() {
			return this.getOperationResults(Type.UPDATE_DML);
		}

		public List<OperationResult> upserted() {
			return this.getOperationResults(Type.UPSERT_DML);
		}

		public List<OperationResult> deleted() {
			return this.getOperationResults(Type.DELETE_DML);
		}

		public List<OperationResult> undeleted() {
			return this.getOperationResults(Type.UNDELETE_DML);
		}

		public List<OperationResult> published() {
			return this.getOperationResults(Type.PUBLISH_DML);
		}

		public OperationResult inserted(SObjectType objectType) {
			return this.getOperationResult(Type.INSERT_DML, objectType);
		}

		public OperationResult updated(SObjectType objectType) {
			return this.getOperationResult(Type.UPDATE_DML, objectType);
		}

		public OperationResult upserted(SObjectType objectType) {
			return this.getOperationResult(Type.UPSERT_DML, objectType);
		}

		public OperationResult deleted(SObjectType objectType) {
			return this.getOperationResult(Type.DELETE_DML, objectType);
		}

		public OperationResult undeleted(SObjectType objectType) {
			return this.getOperationResult(Type.UNDELETE_DML, objectType);
		}

		public OperationResult published(SObjectType objectType) {
			return this.getOperationResult(Type.PUBLISH_DML, objectType);
		}

		private List<OperationResult> getOperationResults(Type operationType) {
			List<OperationResult> operationResults = new List<OperationResult>();

			for (SObjectType objectType : this.operationResultsByObjectType.get(operationType).keySet()) {
				operationResults.add(this.operationResultsByObjectType.get(operationType).get(objectType));
			}

			return operationResults;
		}

		private OperationResult getOperationResult(Type operationType, SObjectType objectType) {
			return this.operationResultsByObjectType.get(operationType).get(objectType) ?? new OperationSummary(objectType, operationType);
		}

		public List<OperationResult> all() {
			List<OperationResult> allResults = new List<OperationResult>();

			for (Type operationType : this.operationResultsByObjectType.keySet()) {
				allResults.addAll(this.operationResultsByObjectType.get(operationType).values());
			}

			return allResults;
		}
	}

	public abstract class DmlOperation {
		protected Map<SObjectType, RecordsContainer> recordsProcessContainerByType = new Map<SObjectType, RecordsContainer>();
		protected List<SObjectType> customExecutionOrder = new List<SObjectType>();
		protected System.AccessLevel accessMode = System.AccessLevel.USER_MODE;
		protected System.AccessType accessType = null;
		protected Database.DmlOptions options = new Database.DMLOptions();
		protected DmlSharing sharingExecutor = new InheritedSharing();
		protected String dmlIdentifier = null;
		protected Boolean allOrNone = true;

		public DmlOperation() {
			this.options.optAllOrNone = this.allOrNone;
		}

		public void userMode() {
			this.accessMode = System.AccessLevel.USER_MODE;
		}

		public void systemMode() {
			this.accessMode = System.AccessLevel.SYSTEM_MODE;
		}

		public void stripInaccessible(System.AccessType type) {
			this.accessType = type;
		}

		public void withSharing() {
			this.sharingExecutor = new WithSharing();
		}

		public void withoutSharing() {
			this.sharingExecutor = new WithoutSharing();
		}

		public void executionOrder(List<SObjectType> customExecutionOrder) {
			this.customExecutionOrder = customExecutionOrder;
		}

		public void identifier(String dmlIdentifier) {
			this.dmlIdentifier = dmlIdentifier;
		}

		public DmlOperation allowPartialSuccess() {
			this.allOrNone = false;
			this.options.optAllOrNone = false;
			return this;
		}

		public DmlOperation skipDuplicateRules() {
			this.options.duplicateRuleHeader.allowSave = true;
			return this;
		}

		public void options(Database.DmlOptions options) {
			this.options = options;
			this.options.optAllOrNone = this.options.optAllOrNone ?? this.allOrNone ?? true;
		}

		public void register(DML.Records records) {
			for (DML.Record record : records.get()) {
				this.register(record);
			}
		}

		public void register(DML.Record record) {
			this.validate(record);
			
			EnhancedRecord enhancedRecord = record.get();
			SObjectType typeName = enhancedRecord.getSObjectType();

			if (!this.customExecutionOrder.isEmpty() && !this.customExecutionOrder.contains(typeName)) {
				throw new DmlException('Only the following types can be registered: ' + this.customExecutionOrder);
			}

			if (!this.recordsProcessContainerByType.containsKey(typeName)) {
				this.recordsProcessContainerByType.put(typeName, new RecordsContainer());
			}

			this.recordsProcessContainerByType.get(typeName).addNewRecordToProcess(enhancedRecord);
		}

		public void preview() {
			System.debug(LoggingLevel.ERROR, '\n\n============ DML Preview ============\n' + JSON.serializePretty(this.recordsProcessContainerByType) + '\n=======================================\n');
		}

		public List<OperationResult> commitWork() {
			return this.sharingExecutor.execute(this);
		}

		public List<OperationResult> execute() {
			if (!this.customExecutionOrder.isEmpty()) {
				return this.processBasedOnCustomOrder();
			} 

			return this.processBasedOnRegistrationOrder();
		}

		private List<OperationResult> processBasedOnCustomOrder() {
			return this.process(this.customExecutionOrder);
		}

		private List<OperationResult> processBasedOnRegistrationOrder() {
			return this.process(this.recordsProcessContainerByType.keySet());
		}

		private List<OperationResult> process(Iterable<SObjectType> objectTypesOrder) {
			List<OperationResult> operationResults = new List<OperationResult>();

			for (SObjectType objectTypeName : objectTypesOrder) {
				if (!this.recordsProcessContainerByType.containsKey(objectTypeName)) {
					continue;
				}

				List<SObject> recordsToProcess = this.recordsProcessContainerByType.get(objectTypeName).getRecordsToProcess(this.accessType);

				DmlMock dmlMock = DML.dmlIdentifierToMock.get(this.dmlIdentifier);

				List<RecordResult> recordResults;

				if (dmlMock == null || !dmlMock.shouldBeMocked(this.getType(), objectTypeName)) {
					recordResults = this.executeDml(recordsToProcess);
				} else {
					recordResults = this.prepareMockedDml(recordsToProcess);
				}
				
				operationResults.add(new OperationSummary(objectTypeName, this.getType()).setRecords(recordsToProcess).setRecordResults(recordResults));
			}

			return operationResults;
		}

		private List<RecordResult> getMockedRecordResults(List<SObject> recordsToProcess) {
			return new List<RecordResult>();
		}

		public abstract Type getType();
		public abstract List<RecordResult> executeDml(List<SObject> recordsToProcess);
		
		public virtual List<RecordResult> prepareMockedDml(List<SObject> recordsToProcess) {
			return new List<RecordResult>();
		}

		public virtual void validate(DML.Record record) {
			return;
		}
	}

	private class RecordsContainer {
		private List<EnhancedRecord> enhancedRecords = new List<EnhancedRecord>();

		public void addNewRecordToProcess(EnhancedRecord enhancedRecord) {
			this.enhancedRecords.add(enhancedRecord);
		}

		public List<SObject> getRecordsToProcess(System.AccessType accessType) { 
			List<SObject> recordsToProcess = new List<SObject>();

			for (EnhancedRecord enhancedRecord : this.enhancedRecords) {
				enhancedRecord.resolveRecordRelationships();
				recordsToProcess.add(enhancedRecord.getRecord());
			}

			if (accessType == null) {
				return recordsToProcess;
			}

			return System.Security.stripInaccessible(accessType, recordsToProcess).getRecords();
		}
		
		public List<Id> getRecordIdsToProcess() {
			List<Id> recordIdsToProcess = new List<Id>();

			for (EnhancedRecord enhancedRecord : this.enhancedRecords) {
				recordIdsToProcess.add(enhancedRecord.getRecordId());
			}

			return recordIdsToProcess;
		}
	}

	public inherited sharing class InsertOperation extends DmlOperation {
		public override Type getType() {
			return Type.INSERT_DML;
		}

		public override void validate(DML.Record record) {
			if (record.get().doesRecordHaveIdSpecified()) {
				throw new DmlException('Only new records can be registered as new.');
			}
		}

		public override List<RecordResult> executeDml(List<SObject> recordsToProcess) {
			List<Database.SaveResult> saveResults = Database.insert(recordsToProcess, this.options, this.accessMode);
			return new SaveResultAdapter(saveResults).transform();
		}

		public override List<RecordResult> prepareMockedDml(List<SObject> recordsToProcess) {
			List<RecordResult> recordResults = new List<RecordResult>();
			
			for (SObject record : recordsToProcess) {
				record.put('Id', DML.randomIdGenerator.get(record.getSObjectType()));
				recordResults.add(new RecordSummary().isSuccess(true).recordId(record.Id));
			}

			return recordResults;
		}
	}

	public inherited sharing class UpdateOperation extends DmlOperation {
		public override Type getType() {
			return Type.UPDATE_DML;
		}

		public override void validate(DML.Record record) {
			if (!record.get().doesRecordHaveIdSpecified()) {
				throw new DmlException('Only existing records can be updated.');
			}
		}

		public override List<RecordResult> executeDml(List<SObject> recordsToProcess) {
			List<Database.SaveResult> saveResults = Database.update(recordsToProcess, this.options, this.accessMode);
			return new SaveResultAdapter(saveResults).transform();
		}
	}

	public inherited sharing class UpsertOperation extends DmlOperation {
		public override Type getType() {
			return Type.UPSERT_DML;
		}

		public override List<RecordResult> executeDml(List<SObject> recordsToProcess) {
			List<Database.UpsertResult> upsertResults = Database.upsert(recordsToProcess, this.allOrNone, this.accessMode);
			return new UpsertResultAdapter(upsertResults).transform();
		}
	}

	public inherited sharing class DeleteOperation extends DmlOperation {
		public override Type getType() {
			return Type.DELETE_DML;
		}

		public override void validate(DML.Record record) {
			if (!record.get().doesRecordHaveIdSpecified()) {
				throw new DmlException('Only existing records can be registered as deleted.');
			}
		}

		public override List<RecordResult> executeDml(List<SObject> recordsToProcess) {
			List<Database.DeleteResult> deleteResults = Database.delete(recordsToProcess, this.allOrNone, this.accessMode);
			return new DeleteResultAdapter(deleteResults).transform();
		}
	}

	public inherited sharing class UndeleteOperation extends DmlOperation {
		public override Type getType() {
			return Type.UNDELETE_DML;
		}

		public override void validate(DML.Record record) {
			if (!record.get().doesRecordHaveIdSpecified()) {
				throw new DmlException('Only deleted records can be undeleted.');
			}
		}

		public override List<RecordResult> executeDml(List<SObject> recordsToProcess) {
			List<Database.UndeleteResult> undeleteResults = Database.undelete(recordsToProcess, this.allOrNone, this.accessMode);
			return new UndeleteResultAdapter(undeleteResults).transform();
		}
	}

	public inherited sharing class PlatformEventOperation extends DmlOperation {
		public override Type getType() {
			return Type.PUBLISH_DML;
		}

		public override List<RecordResult> executeDml(List<SObject> recordsToProcess) {
			List<Database.SaveResult> saveResults = EventBus.publish(recordsToProcess);
			return new SaveResultAdapter(saveResults).transform();
		}
	}
	
	private interface DmlSharing {
		List<OperationResult> execute(DmlOperation executor);
	}

	private inherited sharing class InheritedSharing implements DmlSharing {
		public List<OperationResult> execute(DmlOperation executor) {
			return executor.execute();
		}
	}

	private without sharing class WithoutSharing implements DmlSharing {
		public List<OperationResult> execute(DmlOperation executor) {
			return executor.execute();
		}
	}

	private with sharing class WithSharing implements DmlSharing {
		public List<OperationResult> execute(DmlOperation executor) {
			return executor.execute();
		}
	}

	private class OperationSummary implements OperationResult {
		public SObjectType objectType;
		private Type type;
		public List<RecordResult> recordResults = new List<RecordResult>();
		public List<SObject> records = new List<SObject>();

		public OperationSummary(SObjectType objectType, Type type) {
			this.objectType = objectType;
			this.type = type;
		}

		public OperationSummary setRecords(List<SObject> records) {
			this.records = records;
			return this;
		}

		public OperationSummary setRecordResults(List<RecordResult> recordResults) {
			this.recordResults = recordResults;
			return this;
		}

		public Type getType() {
			return this.type;
		}

		public Boolean hasFailures() {
			return this.failedCount() > 0;
		}

		public Integer requestedCount() {
			return this.records.size();
		}

		public Integer succeededCount() {
			Integer successCount = 0;
			
			for (RecordResult recordResult : this.recordResults) {
				if (recordResult.isSuccess()) {
					successCount++;
				}
			}
			return successCount;
		}

		public Integer failedCount() {
			return this.requestedCount() - this.succeededCount();
		}

		public SObjectType getObjectType() {
			return this.objectType;
		}

		public List<SObject> records() {
			return this.records;
		}

		public List<RecordResult> getRecordResults() {
			return this.recordResults;
		}
	}

	private class RecordSummary implements RecordResult {
		public Id recordId;
		public Boolean isSuccess = false;
		public List<DML.Error> errors = new List<DML.Error>();

		public Id getId() {
			return this.recordId;
		}

		public Boolean isSuccess() {
			return this.isSuccess;
		}

		public List<DML.Error> getErrors() {
			return this.errors;
		}

		public RecordSummary isSuccess(Boolean isSuccess) {
			this.isSuccess = isSuccess;
			return this;
		}

		public RecordSummary recordId(Id recordId) {
			this.recordId = recordId;
			return this;
		}

		public RecordSummary errors(List<Database.Error> errors) {
			for (Database.Error error : errors ?? new List<Database.Error>()) {
				this.errors.add(new RecordProcessingError(error));
			}
			return this;
		}
	}

	private class RecordProcessingError implements DML.Error {
		public String message;
		public System.StatusCode statusCode;
		public List<String> fields;

		public RecordProcessingError(Database.Error error) {
			this.message = error.getMessage();
			this.statusCode = error.getStatusCode();
			this.fields = error.getFields();
		}

		public String getMessage() {
			return this.message;
		}
		public System.StatusCode getStatusCode() {
			return this.statusCode;
		}

		public List<String> getFields() {
			return this.fields;
		}
	}

	private interface DmlAdapter {
		List<RecordResult> transform();
	}

	private class SaveResultAdapter implements DmlAdapter {
		private List<Database.SaveResult> saveResults;

		public SaveResultAdapter(List<Database.SaveResult> saveResults) {
			this.saveResults = saveResults;
		}

		public List<RecordResult> transform() {
			List<RecordResult> recordResults = new List<RecordResult>();

			for (Database.SaveResult saveResult : this.saveResults) {
				recordResults.add(
					new RecordSummary()
						.isSuccess(saveResult.isSuccess())
						.recordId(saveResult.getId())
						.errors(saveResult.getErrors())
				);
			}

			return recordResults;
		}
	}

	private class UpsertResultAdapter implements DmlAdapter {
		private List<Database.UpsertResult> upsertResults;

		public UpsertResultAdapter(List<Database.UpsertResult> upsertResults) {
			this.upsertResults = upsertResults;
		}

		public List<RecordResult> transform() {
			List<RecordResult> recordResults = new List<RecordResult>();

			for (Database.UpsertResult upsertResult : this.upsertResults) {
				recordResults.add(
					new RecordSummary()
						.isSuccess(upsertResult.isSuccess())
						.recordId(upsertResult.getId())
						.errors(upsertResult.getErrors())
				);
			}

			return recordResults;
		}
	}

	private class DeleteResultAdapter implements DmlAdapter {
		private List<Database.DeleteResult> deleteResults;

		public DeleteResultAdapter(List<Database.DeleteResult> deleteResults) {
			this.deleteResults = deleteResults;
		}

		public List<RecordResult> transform() {
			List<RecordResult> recordResults = new List<RecordResult>();

			for (Database.DeleteResult deleteResult : this.deleteResults) {
				recordResults.add(
					new RecordSummary()
						.isSuccess(deleteResult.isSuccess())
						.recordId(deleteResult.getId())
						.errors(deleteResult.getErrors())
				);
			}

			return recordResults;
		}
	}

	private class UndeleteResultAdapter implements DmlAdapter {
		private List<Database.UndeleteResult> undeleteResults;

		public UndeleteResultAdapter(List<Database.UndeleteResult> undeleteResults) {
			this.undeleteResults = undeleteResults;
		}

		public List<RecordResult> transform() {
			List<RecordResult> recordResults = new List<RecordResult>();

			for (Database.UndeleteResult undeleteResult : this.undeleteResults) {
				recordResults.add(
					new RecordSummary()
						.isSuccess(undeleteResult.isSuccess())
						.recordId(undeleteResult.getId())
						.errors(undeleteResult.getErrors())
				);
			}

			return recordResults;
		}
	}

	private class DmlMock implements Mockable {
		private Set<Type> mockedDmlTypes = new Set<Type>();
		private Map<Type, Set<SObjectType>> mockedObjectTypesByDmlType = new Map<Type, Set<SObjectType>>{
			Type.INSERT_DML => new Set<SObjectType>(),
			Type.UPDATE_DML => new Set<SObjectType>(),
			Type.UPSERT_DML => new Set<SObjectType>(),
			Type.DELETE_DML => new Set<SObjectType>(),
			Type.UNDELETE_DML => new Set<SObjectType>(),
			Type.PUBLISH_DML => new Set<SObjectType>()
		};

		public Mockable thenMockAllDmls() {
			return this.thenMockAllInserts()
				.thenMockAllUpdates()
				.thenMockAllUpserts()
				.thenMockAllDeletes()
				.thenMockAllUndelete()
				.thenMockAllPublishes();
		}
		
		public Mockable thenMockAllInserts() {
			return this.thenMockDml(Type.INSERT_DML);
		}

		public Mockable thenMockAllUpdates() {
			return this.thenMockDml(Type.UPDATE_DML);
		}

		public Mockable thenMockAllUpserts() {
			return this.thenMockDml(Type.UPSERT_DML);
		}

		public Mockable thenMockAllDeletes() {
			return this.thenMockDml(Type.DELETE_DML);
		}

		public Mockable thenMockAllUndelete() {
			return this.thenMockDml(Type.UNDELETE_DML);
		}

		public Mockable thenMockAllPublishes() {
			return this.thenMockDml(Type.PUBLISH_DML);
		}

		private Mockable thenMockDml(Type dmlType) {
			this.mockedDmlTypes.add(dmlType);
			return this;
		}

		public Mockable thenMockInsertFor(SObjectType objectType) {
			return this.thenMockDmlFor(Type.INSERT_DML, objectType);
		}

		public Mockable thenMockUpdateFor(SObjectType objectType) {
			return this.thenMockDmlFor(Type.UPDATE_DML, objectType);
		}

		public Mockable thenMockUpsertFor(SObjectType objectType) {
			return this.thenMockDmlFor(Type.UPSERT_DML, objectType);
		}

		public Mockable thenMockDeleteFor(SObjectType objectType) {
			return this.thenMockDmlFor(Type.DELETE_DML, objectType);
		}

		public Mockable thenMockUndeletFor(SObjectType objectType) {
			return this.thenMockDmlFor(Type.UNDELETE_DML, objectType);
		}

		public Mockable thenMockPublishFor(SObjectType objectType) {
			return this.thenMockDmlFor(Type.PUBLISH_DML, objectType);
		}

		private Mockable thenMockDmlFor(Type dmlType, SObjectType objectType) {
			this.mockedObjectTypesByDmlType.get(dmlType).add(objectType);
			return this;
		}

		public Boolean shouldBeMocked(Type dmlType, SObjectType objectType) {
			return this.mockedDmlTypes.contains(dmlType) || this.mockedObjectTypesByDmlType.get(dmlType).contains(objectType);
		}
	}

	private class DmlRecords implements Records {
		private List<SObject> recordsToProcess = new List<SObject>();

		private Map<SObjectField, Object> valueByFieldApiName = new Map<SObjectField, Object>();
		private List<ParentRelationship> parentRelationships = new List<ParentRelationship>();
		private List<ExternalRelationship> externalRelationships = new List<ExternalRelationship>();

		public DmlRecords(List<SObject> records) {
			this.recordsToProcess = records;
		}

		public DmlRecords(Iterable<Id> recordIds) {
			SObjectType objectType = recordIds.iterator().next()?.getSObjectType();

			for (Id recordId : recordIds) {
				this.recordsToProcess.add(objectType.newSObject(recordId));
			}       
		}

		public DmlRecords with(SObjectField field, Object value) {
			this.valueByFieldApiName.put(field, value);
			return this;
		}

		public DmlRecords withRelationship(SObjectField relationshipField, SObject relatedToRecord) {
			this.parentRelationships.add(new ParentRelationship(relationshipField, relatedToRecord));
			return this;
		}

		public DmlRecords withRelationship(SObjectField relationshipField, SObjectField externalIdField, Object externalId) {
			this.externalRelationships.add(new ExternalRelationship(relationshipField, externalIdField, externalId));
			return this;
		}

		public List<DML.Record> get() {
			List<DML.Record> dmlRecords = new List<DML.Record>();

			for (SObject record : this.recordsToProcess) {
				DML.Record dmlRecord = new DmlRecord(record);
				EnhancedRecord enhancedRecord = dmlRecord.get();

				this.populateFieldsValues(enhancedRecord);
				this.populateParentRelationships(enhancedRecord);
				this.populateExternalRelationships(enhancedRecord);

				dmlRecords.add(dmlRecord);
			}

			return dmlRecords;
		}

		private void populateFieldsValues(EnhancedRecord enhancedRecord) {
			for (SObjectField field : this.valueByFieldApiName.keySet()) {
				enhancedRecord.with(field, this.valueByFieldApiName.get(field));
			}
		}

		private void populateParentRelationships(EnhancedRecord enhancedRecord) {
			for (ParentRelationship parentRelationship : this.parentRelationships) {
				enhancedRecord.withRelationship(parentRelationship);
			}
		}

		private void populateExternalRelationships(EnhancedRecord enhancedRecord) {
			for (ExternalRelationship externalRelationship : this.externalRelationships) {
				enhancedRecord.withRelationship(externalRelationship);
			}
		}
	}

	private class DmlRecord implements Record {
		private EnhancedRecord enhancedRecord;

		public DmlRecord(SObject record) {
			this.enhancedRecord = new EnhancedRecord(record);
		}

		public DmlRecord(Id recordId) {
			this.enhancedRecord = new EnhancedRecord(recordId);
		}

		public DmlRecord with(SObjectField field, Object value) {
			this.enhancedRecord.with(field, value);
			return this;
		}

		public DmlRecord withRelationship(SObjectField relationshipField, SObject relatedToRecord) {
			this.enhancedRecord.withRelationship(new ParentRelationship(relationshipField, relatedToRecord));
			return this;
		}

		public DmlRecord withRelationship(SObjectField relationshipField, SObjectField externalIdField, Object externalId) {
			this.enhancedRecord.withRelationship(new ExternalRelationship(relationshipField, externalIdField, externalId));
			return this;
		}

		public EnhancedRecord get() {
			return this.enhancedRecord;
		}
	}

	private class EnhancedRecord {
		private SObject currentRecord;

		private List<ParentRelationship> parentRelationships = new List<ParentRelationship>();
		private List<ExternalRelationship> externalRelationships = new List<ExternalRelationship>();

		public EnhancedRecord(SObject currentRecord) {
			this.currentRecord = currentRecord;
		}

		public EnhancedRecord(Id currentRecordId) {
			if (currentRecordId == null) {
				return;
			}

			this.currentRecord = currentRecordId.getSObjectType().newSObject(currentRecordId);
		}

		public void with(SObjectField field, Object value) {
			this.currentRecord.put(field, value);
		}

		public void withRelationship(ParentRelationship parentRelationship) {
			this.parentRelationships.add(parentRelationship);
		}

		public void withRelationship(ExternalRelationship externalRelationship) {
			this.externalRelationships.add(externalRelationship);
		}

		public void resolveRecordRelationships() {
			this.resolveRelationships();
			this.resolveExternalRelationships();
		}

		private void resolveRelationships() {
			for (ParentRelationship parentRelationship : this.parentRelationships) {
				parentRelationship.resolve(this.currentRecord);
			}
		}

		private void resolveExternalRelationships() {
			for (ExternalRelationship externalRelationship : this.externalRelationships) {
				externalRelationship.resolve(this.currentRecord);
			}
		}

		public SObjectType getSObjectType() {
			return this.currentRecord?.getSObjectType();
		}

		public Boolean doesRecordHaveIdSpecified() {
			return String.isNotBlank(this.getRecordId());
		}

		public SObject getRecord() {
			return this.currentRecord;
		}

		public Id getRecordId() {
			return this.currentRecord?.Id;
		}
	}

	private class ParentRelationship {
		private SObject relatedToRecord;
		private SObjectField relationshipField;

		public ParentRelationship(SObjectField relationshipField, SObject relatedToRecord) {
			this.validateRelationshipField(relationshipField);

			this.relationshipField = relationshipField;
			this.relatedToRecord = relatedToRecord;
		}

		public void resolve(SObject currentRecord) {
			currentRecord.put(this.relationshipField, this.relatedToRecord.Id);
		}

		private void validateRelationshipField(SObjectField relationshipField) {            
			if (String.isBlank(relationshipField.getDescribe().getRelationshipName())) {
				throw new DmlException('Invalid argument: relationshipField. Field supplied is not a relationship field.');
			}
		}
	}

	private class ExternalRelationship { 
		public SObjectField relationshipField;
		public SObjectField externalIdField;
		public SObjectType relatedToType;
		public Object relatedRecordExternalId;

		public ExternalRelationship(SObjectField relationshipField, SObjectField relatedObjectExternalIdField, Object relatedRecordExternalId) {
			this.validateRelatedToField(relationshipField);
			this.validateExternalIdField(relationshipField, relatedObjectExternalIdField);

			this.relationshipField = relationshipField;
			this.relatedToType = relationshipField.getDescribe().getReferenceTo()[0];
			this.externalIdField = relatedObjectExternalIdField;
			this.relatedRecordExternalId = relatedRecordExternalId;
		}  

		public void resolve(SObject currentRecord) {
			SObject relationshipObject = this.relatedToType.newSObject();
			relationshipObject.put(this.externalIdField.getDescribe().getName(), this.relatedRecordExternalId);

			currentRecord.putSObject(this.relationshipField.getDescribe().getRelationshipName(), relationshipObject);
		}

		private void validateRelatedToField(SObjectField relationshipField) {
			if (String.isBlank(relationshipField.getDescribe().getRelationshipName())) {
				throw new DmlException('Invalid argument: relationshipField. Field supplied is not a relationship field.');
			}
		}

		private void validateExternalIdField(SObjectField relationshipField, SObjectField externalIdField) {
			Boolean externalIdFieldIsValid = externalIdField.getDescribe().isExternalId();
	
			if (!externalIdFieldIsValid) {
				throw new DmlException('Invalid argument: externalIdField. Field supplied is not a marked as an External Identifier.');
			}
	
			SObjectType relatedObjectType = relationshipField.getDescribe().getReferenceTo()[0];
			String externalIdFieldName = externalIdField.getDescribe().getName();
	
			Boolean relatedHasExternalIdField = relatedObjectType.getDescribe().fields.getMap().keySet().contains(externalIdFieldName.toLowerCase());
	
			if (!relatedHasExternalIdField) {
				throw new DmlException('Invalid argument: externalIdField. Field supplied is not a known field on the target sObject.');
			}
		}
	}

	public class RandomIdGenerator {
		private final String RANDOM_STRING_CHARACTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz';

		public Id get(SObjectType objectType) {
			return get(objectType.getDescribe().getKeyPrefix());
		}

		public Id get(String prefix) {
			String randomPart = '';

			while (randomPart.length() < 8) {
				Integer idx = Math.mod(Math.abs(Crypto.getRandomInteger()), RANDOM_STRING_CHARACTERS.length());
				randomPart += RANDOM_STRING_CHARACTERS.substring(idx, idx + 1);
			}

			return Id.valueOf(prefix + '0000' + randomPart);
		}
	}
}